Names: Reed Rosenbluth and Jonathan Dubin
Pennkeys: reedros and dubinj

# What was the goal of your project?

The goal of the project was to create an embedded DSL for composing
drum beats.

---------------------------------------------------------------------------

# What was the most significant challenge that you faced in completing
the project?

Determining how to test our code was one challenge. At first, we were
unsure of how we could test our code, since ostensibly, determining
whether a beat was constructed correctly relies on us listening to the
beat and making sure it sounded like we expected. However, we realized
that we could (and should) still test the underlying Haskell
representation of our beats. To that end, we had to refactor the code a
bit to make it amenable to testing. 

---------------------------------------------------------------------------

# What is the most impressive aspect of what you built?

******

---------------------------------------------------------------------------

# What was the most interesting thing you learned?

It can be easy to come away from using Haskell and concluding that
Haskell's powerful type system and the more "algebraic" typeclasses
are great for academic exercise, but would otherwise get in the way
of more practical work. However, throughout the project, it
became very clear that far from getting in the way of development,
Haskell made would have been otherwise hair in other languages,
extremely simply, and we would be happy to talk about this more during
the demo.

# What grade do you feel you deserve for this project, and why?

We feel that we deserve an A for this project, namely because
we really leveraged the power of Haskell to create a cool
and useful project. Everything from creating our own data types,
to arbitrary instances of those types, and instances of the
monad, applicative, functor, and monoid typeclasses. And we
were able to use these to create a project that is a lot of
fun to play with and use. 

---------------------------------------------------------------------------

# Any other comments?

We had a lot of fun working on this project!

---------------------------------------------------------------------------

# What resources did you use in completing the project? 

One resource we looked at for inspiration was the excellent Bang
library (https://hackage.haskell.org/package/Bang).

===========================================================================

# A summary of the files

## src/Types.hs

Types.hs contains the fundamental types that we use throughout
the project. The core types are Sound, Hit, Beat, Composition, and
Song. In addition to defining these types, we also create a number of
typeclass instances, including the arbitrary instances for Sound, Hit,
Beat, and Song that we use for testing. We also define (for some of our types)
type class instances for Functor, Applicative, Ord, Monad, and Monoid. 

---------------------------------------------------------------------------

## src/Play.hs

Play.hs contains the code pertaining to how the music actually
gets generated and play. Once you create a Composition, we need to listen to
it! The `play` function is the principle function here: it's what
users will typically use to play their compositions. The other
functions in this file are called by play to transform the composition
into MIDI events and finally to play the MIDI events on the user's
computer.

---------------------------------------------------------------------------

## src/Drums.hs

The elements and functions defined in Drums.hs will help a user
get started making beats. We include definitions for several basic hits,
like bass drum and high hat hits. We also include functions that the user
can use to easily transform hits to a song, to change the velocity 
of their song, and to loop their songs. The dseq function also let's
users use dseq notation to quickly create beats. For examples of dseq notation,
check out Example.hs.

---------------------------------------------------------------------------

## src/Example.hs

Example.hs contains several beats that have already been
defined, that the user can play around with and use as inspiration
for their own beats. We make liberal use of dseq notation here,
to construct our beats. 

---------------------------------------------------------------------------

## src/Interpret.hs

Interpret contains a number of helper functions related to interpreting 
beats. Two notable functions here are mergeHits and toHits,
which we use to merge two lists of hits, and take a composition and turn it 
into a hit list, respectively.

---------------------------------------------------------------------------

## test/TypesSpec.hs

TypesSpec is home to our QuickCheck tests. Particularly, The tests confirm that
layering beats is associative and commutative, and that sequencing
beats is associative. Because of how the code is organized, these 
tests also test other potions of the code base, including song
construction.

===========================================================================

# Usage:

Dependencies to install: hmidi, lens, random, QuickCheck, hspec, mtl

We used Stack to manage dependencies and build our project.  To build
and install, run `stack build`.  To use, run `stack ghci` and load
Example.hs with `:load example`.  You can play one of our example
beats with `play funky 210`.  To run the test cases, run `stack test`.
